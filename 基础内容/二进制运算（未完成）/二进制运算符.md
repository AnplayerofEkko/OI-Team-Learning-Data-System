#二进制运算符
---
##1、基本概念
逻辑变量之间的运算称为逻辑运算。二进制数1和0在逻辑上可以代表“真”与“假”、“是”与“否”、“有”与“无”。这种具有逻辑属性的变量就称为逻辑变量。计算机的逻辑运算的算术运算的主要区别是：逻辑运算是**按位**进行的，位与位之间不像加减运算那样有进位或借位的联系。
##2、运算符
|运算符|运算|范例|结果|
|---|
|&|与(AND)|0&1|0|
|\||或(OR)|0\|1|1|
|^|异或（XOR）|0^1|1|
|！|非（NOT）|!1|0|
|~|取反|~1|0|
|<<|左移|11100111 << 2 | 10011100|
|\>>|右移|11100111>>2|00111001|
|\>>>|无符号右移|

##3、位运算
>位运算实质是将参与运算的数字转换为二进制，而后逐位对应进行运算。
###(1)按位与(&)
  法则：**两位全为1，结果为1**，即1&1=1，1&0=0，0&1=0，0&0=0 

  特殊用法:

  a、0相与可清零。

  b、与1相与可保留原值，可从一个数中取某些位。

    eg:需要取10101110中的低四位，10101110 & 00001111 = 00001110，即得到所需结果。
    

###(2)按位或(|)
  法则:**两位只要有一位为1，结果则为1，否则结果为0**,即1|1=1，1|0=1，0|1=1，0|0=0。

  特殊用法:

  a、与0相或可保留原值。

  b、与1相或可将对应位置1。

    eg:将X=10100000的低四位置1，使X | 00001111 = 10101111即可。
    
###(3)按位异或(^)
  法则:**两位为“异”，即一位为1一位为0，则结果为1，否则为0。**即1^1=1，1^0=0，0^1=0，0^0=1。(有点类似于求复合函数的单调性。“同增异减”，这里是“同真异假”)


  特殊用法：

  a、使指定位翻转：找一个数，对应X要翻转的各位为1，其余为0，使其与X进行异或运算即可。例如，X=10101110，使低四位翻转，X ^ 00001111 = 10100001。

  b、与0相异或保留原值。例如X ^ 00000000 = 10101110。

  c、交换两变量的值。（比借助容器法、加减法效率高）原理：一个数对同一个数连续两次进行异或运算，结果与这个数相等。

  因此，交换方法为：A = A ^ B，B = A ^ B，A = A ^ B。
  

###（4）按位取反（~）和逻辑非（!）
  按位取反“~”：按位取反1变0，0变1

  逻辑非“！”：逻辑取反, false变true,true变false，在C中，只要不是0就是真

  取反法则 :  **将一个数按位取反**，即~ 0 = 1，~ 1 = 0。

###(5)左移（<<）或右移(>>)
  左移法则:将一个数左移x位，即左边丢弃x位，右边用0补x位。（若正数,高位补0,负数,高位补1）

  右移法则:将一个数右移若干位，右边舍弃，正数左边补0，负数左边补1。每右移一位，相当于除以一次2。
  
###(6)无符号右移
  法则:将一个数右移若干位，左边补0，右边舍弃。(不论正负,高位均补0)

###(7)拓展:
>对于一个数,计算机要使用一定的编码方式进行存储原码, 反码,补码是机器存储一个具体数字的编码方式。

  a、**原码**：一个整数按照绝对值大小转换为二进制即为原码；
      [+1]原 = 0000 0001
      [-1]原 = 1000 0001
      一个8位二进制数的取值范围为[1111 1111，0111 1111],即[-127,127]
  
  b、**反码**：正数的反码是其本身,负数的反码是在其原码的基础上,符号位不变，其余各个位取反。
      [+1] = [00000001]原 = [00000001]反
      [-1] = [10000001]原 = [11111110]反

  c、**补码**：正数的补码就是其本身,负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1.(即在反码的基础上+1)
      [+1] = [00000001]原 = [00000001]反 = [00000001]补

      [-1] = [10000001]原 = [11111110]反 = [11111111]补






