# 最小生成树：prim和kruskal算法

2018.06.08 作者：王樾

---

## 前面的话

最小生成树是初赛中的考点之一，主要在阅读程序题目中出现，出现什么算法会自己提示给你，只需要补充其中的步骤。

如果想要稳稳地进入复赛，掌握这方面的内容是更有保障的。

## 最小生成树（MST）

何谓生成树？

用我自己的话来理解的话就是**将一张图所有的点连接起来的树**。

什么是树？自行打开前面的内容复习！

有一个重要结论：**一个有n个结点的树，其边一定有$n-1$条**！

一般要求用`最少的代价`使一张图连通，就是让你求最小生成树。

还有一个结论：**最小生成树中一定没有环**！

容易理解：你见过什么树里面有环的吗？

上面这两个标粗体的结论，就是我们求最小生成树的核心思想！

接下来开始介绍算法。

## prim算法

prim算法基于一种红白点思想，用到了一个贪心的结论：**每次添加一个距离生成树最短的未添加的结点，一定是最小生成树的一部分**！

有兴趣的同学可以百度一下证明过程。这里只介绍实现部分。

算法流程是这样的：

1. 维护minv数组，表示某个点距离最小生成树的最短距离；维护vis数组，表示是否被访问过。

2. 选择任意一个点作为起始点（题目无特别要求一般为1）。那么这个点就是生成树的一部分了！

3. 跟上面一样，每次选择与最小生成树距离最小的点加入最小生成树。

4. 添加完点之后，以这个点为起点，更新minv数组。最小代价加上这条边权。

5. 添加点的过程只需要$n-1$步，因为第一次已经添加了一个点了。如果还没添加完的话就跳回第3步。

6. 输出最小代价即可。

时间复杂度为$O(n^2)$，因为添加点需要$n-1$次，查找最小距离需要$n$次。

代码实现在文件夹内，自行阅读。不给注释，锻炼阅读能力。

## kruskal算法

kruskal算法又用到了一个结论：**边权最小的边，只要能够添加，就必定是最小生成树的一部分**！

同样不给出证明，只介绍实现。

给出算法流程：

1. 读入所有的边，一般使用`struct`存入一条边的起点、终点、边权。

2. 最关键的一步：**将这些边按照边权从小到大排序！**

3. 接下来按照上面的思想，从最小的边开始访问。**如果添加这条边后能保证不会构成环**，就添加这条边。

4. 添加边的步骤只有$n-1$步。其实不加也无所谓，因为加了$n-1$条边后，一定每个点都连通。

5. 加上所有边的代价，即为最小代价。

但是问题来了：**如何判断连通？**

答案是：**使用并查集（Union Find Set, UFS）**。

并查集的介绍请百度搜索“并查集”，它是判断连通的优美的数据结构，思想非常美妙。

所以只需要在上面的基础上添加关于并查集的合并、查询操作即可。

时间复杂度应该是$O(ElogE)$，因为对边进行排序，而快排的复杂度为$O(nlogn)$。

代码在文件夹内，涉及并查集的进行注释。

## 算法的选用

prim算法适用于稠密图，kruskal适用于稀疏图。

类比于存图方式，邻接矩阵适用于稠密图，邻接表适用于稀疏图。当然存图方式还有用vector存的。

一般还是kruskal算法用得多，prim在我写这篇文章之前我就不会写。

再见！