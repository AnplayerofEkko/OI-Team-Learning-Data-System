# 最短路：floyd、dijkstra、SPFA算法

2018.06.17 作者：王樾

---

## 前面的话

最短路是图论的较基础内容，但相对于前面的内容更有挑战性。

一般设置在完善程序的最后一题，作为图论内容考察。

如果能掌握一条大题的分，其实复赛也不远了。（这是真的）

## 概念介绍

我们把在一个图上，从一个点到另一个点，能经过的最小边权或点权之和，成为最短路。

这种说法给了我们对边权的一种感性理解，可以理解为是一种长度。

其实我更同意的说法是经过这条边或者这个点所需要花费的代价。

一般给你一张图，问你**一个点到一个点的最小代价、最短距离、最快时间**等问题，可以抽象成为最短路模型。

## 最短路算法

这里介绍三种最短路算法：floyd、dijkstra、SPFA算法。

### floyd算法

floyd算法的本质是动态规划（dynamic programming, dp）。这里不对dp做深刻介绍。

在csdn上找到了一个解释，出处：https://blog.csdn.net/zhao5502169/article/details/77505811

![](https://img-blog.csdn.net/20170823144027524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbzU1MDIxNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

看不懂也没有关系，随着以后的学习，相信很快就能弄懂的。

那么弄到最后，发现只与$f[i][j]$和$f[i][k]+f[k][j]$有关。

即使不看上面的证明，你也许也能发现：i、j间的最短路，就从这两个值更新而来。

如何更新？取最小值！

代码虽然简短（只有四行），但也有值得注意的地方。

代码请看文件夹中的floyd.cpp文件。

求出来的G[i][j]就是这两点间的最短路。并且无论什么点都能查询。这就是所谓的**多源最短路算法**。

因为三个循环，所以算法时间复杂度$O(n^3)$，该算法一般使用邻接矩阵储存。

之前说过，不连通一般使用路径长度为INF，才能避免被floyd更新。

### dijkstra算法

dijkstra算法与一个前面的算法有异曲同工之妙。先不告诉答案。

dijkstra是单源最短路算法，即只能更新出一个起点对所有点的最短路径。

dijkstra算法的核心思想是这么一个结论：**目前的最短路，加上最短的边权到达一个点，则这一条路必定是最短路**！

证明并不会，愿意的同学可以自行百度。

因为里面的“最短边权”，可以看出这是一种贪心的算法。每次寻找当前未访问的点的最短距离，然后层层扩展，层层更新。

所运用的数组共有两个：dist数组，表示从起点到该点的最短路；vis数组，表示是否访问过。

初始化dist数组，可以把以起点的第二维全部搬进dist数组。

具体参见“dijkstra.cpp”，里面有详细注释。

算法时间复杂度为$O(n^2)$，一般也是用邻接矩阵储存。

这里附上刘汝佳《算法竞赛入门经典（第二版）》中dijkstra算法的伪代码：

```
清除所有点的标号
设d[0]=0，其他d[i]=INF
循环n次 {
    在所有未标号结点中，选出d值最小的结点x
    给结点x标记
    对于从x出发的所有边(x,y)，更新d[y] = min{d[y], d[x]+w(x,y)}
}
```

前面说了这个算法与前面的某一个算法很像，答案是：**prim算法**！

共同点是：都使用贪心思想、都是一种蓝白点思想、用到的数组完全一致。

所谓的蓝白点思想由vis数组体现。vis为0的是白点，vis为1的是蓝点。

所以其实prim算法也有堆优化。

### ps：堆优化的dijkstra算法

考虑一下为什么未优化的dijkstra复杂度为什么是$O(n^2)$。

第一个循环用来进行$n-1$次扩展，第二个循环用来找出最小边（dist最小的）与该边终点。

我们可以优化第二个循环，有一个数据结构可以轻松地拿出最小值：堆(heap)。

这里给出啊哈磊关于堆的介绍，同学们自行阅读：

http://www.cnblogs.com/ahalei/p/3783543.html

https://www.cnblogs.com/ahalei/p/3792155.html

便捷的STL实现方式是使用**优先队列**(priority_queue)。

那么我们可以把边权与边的终点用一个struct整合到一起，然后按边权维护小根堆，取出堆首就是最小值了。

同样给出代码实现，参见“dijkstra + heap.cpp”。

算法复杂度为$O(nlogm)$，对于稀疏图比较好，稠密图使用堆优化有时还会更慢。

为什么有个$logm$？因为堆插入$O(logn)$，堆删除堆顶$O(logn)$。

### SPFA算法

#### 小趣事

SPFA算法，其英文名称是Shortest Path Faster Algorithm，名字好像很高级，但其实就是Bellman-Ford算法的队列优化而已。

其实这种算法在Bellman-Ford算法论文上就提出来了，然后名为段凡丁的这个人挖出了这个队列优化，发表了篇论文，结果声名大噪。。。

他通过随机实践，就说该算法的时间复杂度为$O(KE)$，其中K是小常数，约等于2。。。

其实，该算法达到最坏复杂度时，该小常数与N同阶。。。也就相当于没有优化。

这个故事告诉我们：证明当然要严谨地证明，不然出糗了就尴尬了。

#### 正文

首先简单地介绍Bellman-Ford算法，也很简单。通过$n-1$轮，每一轮操作遍历所有的边进行松弛(relax)操作。

所谓松弛，说白了就是(s, v)路径分解为(s, u) + (u, v)路径，而(s, v)路径的答案取不分解与分解两种情况中权值的最小值。

代码不打，也不重要。一般我们使用SPFA，最慢也就跟它一样快。

SPFA思想大致与上述思想差不多，但实际代码样子也有很大的区别。

需要用到的数组：dist数组，单源最短路都要的；vis数组，判断是否在队列中。

首先一样起点dist为0，其他点为INF。然后把起点扔进队列中，等待更新。

只要队列不为空，就说明还需要松弛，就取出队首元素，队首出队。

拿出该点后，遍历以之为起点的所有边，如果能松弛，那么我们就松弛。

能松弛的点，我们一般会加入队列，但是重复添加可能会影响速度，所以只当没有在队列中，我们才加入队列。

代码实现在“SPFA.cpp”中。

算法复杂度上面已经说了，玄学复杂度。但是随机图实践性很好。

## 各种算法使用范围

### 对存图方式

一般如果使用邻接矩阵的话，就意味着点比较少或者边比较多。一般直接floyd都差不多能过，而如果题目只要单源的话，就使用不优化的dijkstra。

而使用邻接表的话，可以使用堆优化版dijkstra或者SPFA。两者对随机图都是差不多的。

### 对图的性质

正权图对dijkstra和SPFA都没问题，而负权图dijkstra算法就不能使用了。此时就只能使用SPFA算法。

### 对出题人

SPFA因为最坏复杂度是$O(nm)$或者$O(VE)$（两者等价），所以一些出题人会在一两个测试点上出极端情况卡掉SPFA。

当然，如果题目是负权图，那么出题人就不会卡SPFA了吧。。。

## 最后的话

这些最短路内容，开始学的时候一般是靠死记的。不过慢慢就会明白的。

这是初赛内容的选学部分，所以会有点难。但是如果想~~公费去广州~~那么就应该认真学。

再见。。。
