# 排序算法

2018.06.24 作者：王樾

---

## 排序算法简介

排序算法，是最最经典的算法内容了，外行人问到算法，也许排序是他们最熟悉的了吧。

排序，说白了就是把一堆无序的数变成有序排列的数。

借助许多有趣的图片，我们着重学习四种排序：**冒泡排序**、**归并排序**、**快速排序**、**堆排序**。

下面会附上一张图表，集中归纳了排序算法的时间复杂度、稳定性等等。

下文排序默认是按升序来排序的。

## 冒泡排序

冒泡排序(Bubble Sort)，是最简单的排序算法，但算法跑得也慢。

该排序思想是：每一次遍历，如果找到逆序的两个数，那么就把它们交换。

可以发现：这个算法遍历一次是不大可能直接排好的，所以需要更多次遍历。

具体多少次呢？

其实每一次遍历，就相当于将最大的元素“冒泡”上去，而总共有$n$个数，所以需要$n-1$次遍历。

所以明白了：做$n-1$次遍历，然后每一次遍历，如果这个数比后一个数大，就跟他换位置。

这样只需要$n-1$次“冒泡”就能解决问题。

代码也非常容易实现，在“bubble.cpp”中给出。

时间复杂度是多少呢？答案是$O(n^2)$。

算法是稳定的，何为稳定？就是相同大小的元素在排序后相对位置不改变。

## 其他$O(n^2)$的排序

文件夹中有ppt，可以在里面了解一下。掌握大致思想即可。

## 归并排序

在看归并排序(merge sort)之前，先要深入地理解递归。因为归并排序使用分治法，而分治法就是通过递归实现。

先给大家看一张图：

![](https://pic4.zhimg.com/v2-86d1dff497b6e17797c90d8166f73e47_b.gif)

这个算法有这么一个特点：把两个有序的序列合并成一个有序的序列。

思考一下为什么可行？因为把这个序列一直拆成两半，拆到只有一个元素的时候有序，合并成两个元素也会有序，以此类推，最终的序列也会有序。

分治法有一个固定操作：先分后合。我在这个Markdown里面给出代码，方便讲：

```cpp
void msort(int l, int r)
{
    int mid = (l + r) >> 1;
    if(l != r) msort(l, mid), msort(mid + 1, r);//如果不是一个点就一分为二
    int i = l, j = mid + 1, k = l;//分别是左半部分、右半部分、t数组的哨兵
    while(i <= mid && j <= r)
    {
        if(a[i] <= a[j]) t[k++] = a[i++];
        else t[k++] = a[j++];
    }
    while(i <= mid) t[k++] = a[i++];//这两句只会执行一句，但都可能发生
    while(j <= r) t[k++] = a[j++];
    for(i = l; i <= r; i++) a[i] = t[i];//搬回a数组
}
```

这里运用了分治思想，运用了递归，刚刚学习编程的你可能会懵了。

如果是的话，那么对这个算法，你只需要感性理解就可以了。重在思想的掌握。代码的实现等编程能力上去之后自然就会了。

时间复杂度：每一次归并是$O(n)$的，而总共进行$logn$次划分，所以复杂度为$O(nlogn)$。

归并排序是稳定的。

## 快速排序

快速排序(quick sort)是最常用的排序，STL里面有个sort函数，其实就是快速排序。之后我们直接使用它就可以。

光说的话当然难理解，同样盗来一张图：

![](https://upload-images.jianshu.io/upload_images/1845730-d7764aaecd2080ff.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/371)

然后也直接扔给你代码：

```cpp

```

算法思想是这样的：

1. 在待排序区间内任取一个数temp。

2. 设i、j两个哨兵，分别找到大于temp和小于temp的两个数，然后交换位置。

3. 可能会剩下两个地方没有排序，如果有这块区间就将这段区间执行一次快速排序。

其实上面这么多行，相当于这么一句话: `std::sort(a + 1, a + 1 + n);`

我个人认为快排比归并排序难写，所以同样了解就好了。

## 堆排序

堆(heap)是一种神奇的数据结构，它是一颗完全二叉树。

它有这么一个性质：

- 当它是小根堆时，**父结点的值小于子结点的值**。

- 当它是大根堆时，**父节点的值大于子结点的值**。

堆的维护就不管了，愿意的话可以百度搜索一下堆。

堆也有STL，名字叫做`priortity_queue`（优先队列）。

使用`top()`取出堆顶，`pop()`删除堆顶，`push(x)`加入x元素。

堆排序的意思其实很暴力：把你要排序的数字都添加进一个堆里面，再取堆顶，删除堆顶，直到堆空为止。

堆特有的性质是添加删除$O(logn)$的复杂度，所以堆排序的复杂度为$O(nlogn)$。

如果使用优先队列的话常数会略大，STL常数都略大，有的硕大。。。

## 后面的话

哈哈，写完了！

排序算法是比较有意思的算法，也是算法的起步吧。

所以别以为信息学竞赛就是学C++的。

有了算法的基础，就能够在接下来的算法学习中逐步渐进，直至成功哦！

再见！

## 参考文献

1. https://zhuanlan.zhihu.com/p/37430943 你“听”过这些经典排序算法吗？

2. 第2章  数据排序(C++版).ppt

3. https://www.luogu.org/problemnew/solution/P1177 luogu快速排序题解