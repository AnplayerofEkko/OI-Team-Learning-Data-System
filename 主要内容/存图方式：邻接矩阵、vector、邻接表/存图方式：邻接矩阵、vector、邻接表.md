# 存图方式：邻接矩阵、vector、邻接表

2018.06.17 作者：王樾

---

## 知识引入

前面我们有学习有关图的知识，知道了各种图的种类、性质等。

如果没有把图存起来的话，空谈图又有什么意义呢？

## 概念介绍

存图，就是将图的有关信息记录下来。

比如从1点到3点有一条边权为2的有向路径。那么将这个信息记录下来的方法就是存图方式。

## 存图方式

目前我所知的存图方式有三种：**邻接矩阵**、**邻接表**、**vector**。

三种存图方式各有好处，下面来介绍。

### 邻接矩阵

先解释下名称。邻接，意思是**内存空间是连续的**。矩阵，可以类似于**二维数组**，是差不多的。

邻接矩阵，说白了就是使用一个二维数组，将图的信息记录下来。

设这张图有$n$个结点，那我们一般就要开一个`G[n + 1][n + 1]`的二维数组。（G是grapics的简称）

为什么要加1？因为数组的第一位是0，开$n+1$的话最后一位是$n$。

一般不将图的编号向前挪一位，把1变成0。**其实只是浪费一点点空间并不多**。

那么我们就有$n^2$个结点，第一维表示一条路的起点，第二维表示终点。其实`G[i][j]`的意思就是询问i点到j点的路径长度。

所以对于1点到3点有一条边权为2的有向路径，我们只要进行一个操作：`G[1][3] = 2;`就可以直接添加这一条边。

怎么表示两个点不连通？一般的方法是记录他们的距离为INF（无穷大）。这个INF由题目决定。INF过大，松弛时可能会出问题。INF过小，可能变成图的一部分。

初始状态当然所有点都不连通，所以**邻接矩阵初始化的时候记得全都赋为INF**！

初始化邻接矩阵可以用一个便捷的操作解决：`memset(G, 0x3f, sizeof(G));`最后会解释这个操作。

在https://www.cnblogs.com/XMU-hcq/p/6065057.html找到了一张图片。

![](https://images2015.cnblogs.com/blog/1005320/201611/1005320-20161115153351529-548277748.png)

这里没有边权，所以将有边设为1。

这里把没有边连接设为0不好。这样不方便我们判断连通以及算最短路（后面的知识）。现在请大家不要像这样做。

memset操作其实原来是用来操作字符串数组的。一个char是8位二进制表示的，而一个int一般是32位的。所以使用memset给char数组赋值0x3f，将来得到的每一个元素值都是0x3f。而给int赋值的结果将会是0x3f3f3f3f。因为32/8=4，所以会重复四次。所以解释了memset给数组赋值时有时会出现奇怪的数。而赋值0是没问题的，思考一下为什么。

### 邻接表

上面的邻接矩阵是针对点来建立的，针对的是点与点之间的关系。而邻接表更针对的是边。

这里介绍的是数组实现的邻接表。一般也是这种用法。

邻接表使用的是一种链式的思想，将所有起始点相同的边串成一条链表，每次添加一条边，就将这条边插入在链表的头部。

如果想要遍历一个点所连接的所有点的话，直接在链表上进行询问即可。

具体图示可以看下这个博客：https://www.cnblogs.com/ahalei/p/3651334.html

然后介绍代码实现，我先给出代码：

```cpp
struct Edges
{
    int next, to, weight;
} e[maxm];//有向图不用改，无向图要乘2
int head[maxn], tot;
```

这是一个标准的邻接表。这里自定义了一个Edges结构，表示的是一条边。

next表示这条边在链表中的下一个元素，to表示这条边的终点，weight表示边权。

head[i]表示以i为起点的链表的第一个元素。

tot表示边的编号，因为是链式存储，所以内存空间并不需要连续。

如何添加一条边？给出代码：

```cpp
void link(int u, int v, int w)
{
    tot++;
    e[tot].to = v;
    e[tot].weight = w;
    e[tot].next = head[u];
    head[u] = tot;
}
```

主要问题在于最后的操作。这个操作的意思是将一个元素添加到链表首部。

为什么不要顺序地添加到尾部？因为如果添加到尾部，就需要进行一次对该链表的遍历，找到最后一个后再进行修改。相比于直接添加到首部，耗费的时间更多，性能不优秀。

如何枚举以某个点u为起点的所有边？代码如下：

```cpp
for(int i = head[u]; i; i = e[i].next)
{
    //do something you want to do
}
```

注意：i表示的是边的编号。想要取得相应的信息需要在e数组中取得。

### vector

这种存图方式并不常见，但也有人用。大家了解一下即可。

其实vector的存图方式是模仿邻接表的。这种存图方式有时像邻接矩阵，有时像邻接表。

这是它的核心内容：`std::vector<int> G[maxn];`

vector是一种不定长的数组，自动省略了第二维。它的第一维是定长的，而第二维不定长。

如何插入边？其实就一句话：`G[u].push_back(v);`

如何遍历一个点为起点的边？也是用for循环展开：

```cpp
for(int i = 0; i < G[u].size(); i++)
{
    int v = G[u][i];
    //do something you want to do
}
```

这里的i就没什么意义了，只是用来取出v。

上面的例子只放了个v进去，但是如果想维护的图有边权怎么解决？

使用std::pair或者自定义一个包含v和weight的结构即可。然后上面的<int>变为结构名称。请同学们自己实现。

## 各种存图方式的优缺点

### 邻接矩阵

查询路径或判断连通$O(1)$，遍历边$O(n)$，修改$O(1)$。

适用于稠密图。

### 邻接表

查询路径或判断连通最坏$O(e)$（这里的e代表所在链表长度），遍历边也是$O(e)$，修改$O(1)$。

适用于稀疏图。

vector就不介绍了。

## 后面的话

存图方式是接下来各种图论算法的基础，也非常重要。

希望大家能够学到。

再见。。。

## 参考资料

http://www.cnblogs.com/ahalei/ 这是啊哈磊的博客，他写的很多东西浅显易懂还有趣，大家可以去了解一波。