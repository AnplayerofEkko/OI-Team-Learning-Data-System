# 递归
tips：本蒟蒻的第一篇博客
***
在学完顺序，条件和循环结构后，摆在OIer面前的
第一道门槛便出现了，那便是
![](http://img01.sogoucdn.com/app/a/100520021/7ea99ae720db8514b8925d9263d8c028)
***
进入正题：

* ### 递归der定义
	递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。                                                                        
![](https://ws1.sinaimg.cn/large/6af89bc8gw1f8quiwiufkj20af09gaa4.jpg)
	
	就....就就就我用我记几吗。
* ### 一个小栗子
  	```cpp
  	int f(int x)
  	{
	  	if(x==1||x==2) return 1;
	  	return f(x-1)+f(x-2); 
  	}
  	```
  	这就是大名鼎鼎的 **斐波那契数列**
  
  	就是1,1,2,3,5,8,13....;
	
	那么这样一个程序是如何运作的呢
	
	![ 如图 ](http://www.spasvo.com/ckfinder/userfiles/images/20130110_5.png)
	
	在我们输入6之后,程序开始将f(6)拆分成f(5)和f(4)再依照此程序对f(5)和f(4)进行拆分,直到来到了**边界条件**f(1)和f(2)。
	此时再返回至f(3),f(4)得出f(3),f(4)的值后再计算f(5),f(6)
	
	若是将递归的内容全部朴素的写出来
	```cpp
	int f(int x)
  	{
	  	if(x==1||x==2) return 1;
	  	int x1=x-1,x2=x-2;
		if(x1==1||x1==2) x1=1;
		else
		{
			int x11=x1-1,x12=x1-2;
			if(x11==1||x11==2) x11=1;
			else
			{
				.......
			}
		} 
  	}
	```
	可以看出，递归能够让我们无数次的运行同一段代码，进行计算机最擅长的：**重复运算**
* ### 递归与循环的区别
	这时可能有人要问了,那递归和循环有什么区别呢？？？？

	的确，我在一开始学递归的时候也是将其看作一种特殊的**循环**。

	在上一波官方解释
	
	>1.程序独立性
	>
	>递归由程序和系统共同完成。递归需要系统维护一个系统工作栈。
	>
	>循环由程序单独完成。但是，循环需要程序设定好循环条件。
	>
	>2.程序规模
	>
	>递归的规模很小，受到系统工作栈大小的限制。
	>
	>循环的规模很大，几乎不会受到限制。
	>
	>在VS2012中计算1+2+3+······+n
	>
	>使用递归n只能达到4710.
	>
	>使用循环n可以达到20 0000 0000.
	>
	>3.复用单位
	>
	>递归的复用单位是函数。
	>
	>循环的复用单位是语句（for循环语句或while循环语句）。
	>
	
	有很多算法都是用到递归的，最好的一个例子便是关于树的前中后序遍历。用递归的实现分别是
	```cpp
	void qian(tree i)//前序遍历
	{
		cout<<tree->root;//输出根的信息
		qian(i->lchild);
		qian(i->rchild);
	}
	void zhong(tree i)//中序遍历
	{
		zhong(i->lchild);
		cout<<tree->root;//输出根的信息
		zhong(i->rchild);
	}
	void hou(tree i)//后序遍历
	{
		hou(i->lchild);
		hou(i->rchild);
		cout<<tree->root;//输出根的信息
	}
	```
	这样的三行代码简单清晰明了
	
	而关于非递归实现，~~我以前是写过的但是找不到了。。。~~
	我这样的蒟蒻只能从网上找代码了
	```cpp
	void DLR(BinaryTree *p) //前序遍历非递归算法
	{
    stack<BinaryTree> *s;    //定义堆栈s
    BinaryTree *p=root;    //指向根节点
    while(p!=NULL || !s.empty())    
    {
        while(p!=NULL)
        {
            cout<<p->data<<endl;
            s.push(p);
            p=p->lchild;
        }
        if(!s.empty())
        {
            p=s.top();
            s.pop();
            p=p->rchild;
        }
    }
	```
	大家不用关心看不看得懂，说是不是很长就可以了
***
差不多就完啦，本蒟蒻的第一篇博客，写得不好多多见谅。
